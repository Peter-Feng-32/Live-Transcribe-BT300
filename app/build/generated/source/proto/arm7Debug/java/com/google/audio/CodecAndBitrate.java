// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: com/google/audio/codec_and_bitrate.proto

package com.google.audio;

/**
 * <pre>
 * In Java, (and excluding the FLAC entry) the bitrate in kilobits per second
 * can be obtained using CodecAndBitrate's getNumber() function.
 * </pre>
 *
 * Protobuf enum {@code audio.CodecAndBitrate}
 */
public enum CodecAndBitrate
    implements com.google.protobuf.ProtocolMessageEnum {
  /**
   * <pre>
   * Do not pass this to the encoder.
   * </pre>
   *
   * <code>UNDEFINED = 0;</code>
   */
  UNDEFINED(0),
  /**
   * <code>AMRWB_BITRATE_6KBPS = 6600;</code>
   */
  AMRWB_BITRATE_6KBPS(6600),
  /**
   * <code>AMRWB_BITRATE_8KBPS = 8850;</code>
   */
  AMRWB_BITRATE_8KBPS(8850),
  /**
   * <code>AMRWB_BITRATE_12KBPS = 12650;</code>
   */
  AMRWB_BITRATE_12KBPS(12650),
  /**
   * <code>AMRWB_BITRATE_14KBPS = 14250;</code>
   */
  AMRWB_BITRATE_14KBPS(14250),
  /**
   * <code>AMRWB_BITRATE_15KBPS = 15850;</code>
   */
  AMRWB_BITRATE_15KBPS(15850),
  /**
   * <code>AMRWB_BITRATE_18KBPS = 18250;</code>
   */
  AMRWB_BITRATE_18KBPS(18250),
  /**
   * <code>AMRWB_BITRATE_19KBPS = 19850;</code>
   */
  AMRWB_BITRATE_19KBPS(19850),
  /**
   * <code>AMRWB_BITRATE_23KBPS = 23050;</code>
   */
  AMRWB_BITRATE_23KBPS(23050),
  /**
   * <code>AMRWB_BITRATE_24KBPS = 23850;</code>
   */
  AMRWB_BITRATE_24KBPS(23850),
  /**
   * <pre>
   * For FLAC, the bitrate isn't specified.
   * </pre>
   *
   * <code>FLAC = 1;</code>
   */
  FLAC(1),
  /**
   * <pre>
   * Note: Opus isn't actually limited to specific bitrates like AMRWB is.
   * Note that because we run the OggOpusEncoder in low-latency mode, the
   * actual bitrate may be larger than this. See the ogg_opus_encoder lib for
   * details.
   * The effect of this will be larger at low bitrates and low block
   * sizes. This is the bitrate used to configure the codec.
   * </pre>
   *
   * <code>OGG_OPUS_BITRATE_12KBPS = 12000;</code>
   */
  OGG_OPUS_BITRATE_12KBPS(12000),
  /**
   * <code>OGG_OPUS_BITRATE_16KBPS = 16000;</code>
   */
  OGG_OPUS_BITRATE_16KBPS(16000),
  /**
   * <code>OGG_OPUS_BITRATE_24KBPS = 24000;</code>
   */
  OGG_OPUS_BITRATE_24KBPS(24000),
  /**
   * <code>OGG_OPUS_BITRATE_32KBPS = 32000;</code>
   */
  OGG_OPUS_BITRATE_32KBPS(32000),
  /**
   * <code>OGG_OPUS_BITRATE_64KBPS = 64000;</code>
   */
  OGG_OPUS_BITRATE_64KBPS(64000),
  /**
   * <code>OGG_OPUS_BITRATE_96KBPS = 96000;</code>
   */
  OGG_OPUS_BITRATE_96KBPS(96000),
  /**
   * <code>OGG_OPUS_BITRATE_128KBPS = 128000;</code>
   */
  OGG_OPUS_BITRATE_128KBPS(128000),
  ;

  /**
   * <pre>
   * Do not pass this to the encoder.
   * </pre>
   *
   * <code>UNDEFINED = 0;</code>
   */
  public static final int UNDEFINED_VALUE = 0;
  /**
   * <code>AMRWB_BITRATE_6KBPS = 6600;</code>
   */
  public static final int AMRWB_BITRATE_6KBPS_VALUE = 6600;
  /**
   * <code>AMRWB_BITRATE_8KBPS = 8850;</code>
   */
  public static final int AMRWB_BITRATE_8KBPS_VALUE = 8850;
  /**
   * <code>AMRWB_BITRATE_12KBPS = 12650;</code>
   */
  public static final int AMRWB_BITRATE_12KBPS_VALUE = 12650;
  /**
   * <code>AMRWB_BITRATE_14KBPS = 14250;</code>
   */
  public static final int AMRWB_BITRATE_14KBPS_VALUE = 14250;
  /**
   * <code>AMRWB_BITRATE_15KBPS = 15850;</code>
   */
  public static final int AMRWB_BITRATE_15KBPS_VALUE = 15850;
  /**
   * <code>AMRWB_BITRATE_18KBPS = 18250;</code>
   */
  public static final int AMRWB_BITRATE_18KBPS_VALUE = 18250;
  /**
   * <code>AMRWB_BITRATE_19KBPS = 19850;</code>
   */
  public static final int AMRWB_BITRATE_19KBPS_VALUE = 19850;
  /**
   * <code>AMRWB_BITRATE_23KBPS = 23050;</code>
   */
  public static final int AMRWB_BITRATE_23KBPS_VALUE = 23050;
  /**
   * <code>AMRWB_BITRATE_24KBPS = 23850;</code>
   */
  public static final int AMRWB_BITRATE_24KBPS_VALUE = 23850;
  /**
   * <pre>
   * For FLAC, the bitrate isn't specified.
   * </pre>
   *
   * <code>FLAC = 1;</code>
   */
  public static final int FLAC_VALUE = 1;
  /**
   * <pre>
   * Note: Opus isn't actually limited to specific bitrates like AMRWB is.
   * Note that because we run the OggOpusEncoder in low-latency mode, the
   * actual bitrate may be larger than this. See the ogg_opus_encoder lib for
   * details.
   * The effect of this will be larger at low bitrates and low block
   * sizes. This is the bitrate used to configure the codec.
   * </pre>
   *
   * <code>OGG_OPUS_BITRATE_12KBPS = 12000;</code>
   */
  public static final int OGG_OPUS_BITRATE_12KBPS_VALUE = 12000;
  /**
   * <code>OGG_OPUS_BITRATE_16KBPS = 16000;</code>
   */
  public static final int OGG_OPUS_BITRATE_16KBPS_VALUE = 16000;
  /**
   * <code>OGG_OPUS_BITRATE_24KBPS = 24000;</code>
   */
  public static final int OGG_OPUS_BITRATE_24KBPS_VALUE = 24000;
  /**
   * <code>OGG_OPUS_BITRATE_32KBPS = 32000;</code>
   */
  public static final int OGG_OPUS_BITRATE_32KBPS_VALUE = 32000;
  /**
   * <code>OGG_OPUS_BITRATE_64KBPS = 64000;</code>
   */
  public static final int OGG_OPUS_BITRATE_64KBPS_VALUE = 64000;
  /**
   * <code>OGG_OPUS_BITRATE_96KBPS = 96000;</code>
   */
  public static final int OGG_OPUS_BITRATE_96KBPS_VALUE = 96000;
  /**
   * <code>OGG_OPUS_BITRATE_128KBPS = 128000;</code>
   */
  public static final int OGG_OPUS_BITRATE_128KBPS_VALUE = 128000;


  public final int getNumber() {
    return value;
  }

  /**
   * @deprecated Use {@link #forNumber(int)} instead.
   */
  @java.lang.Deprecated
  public static CodecAndBitrate valueOf(int value) {
    return forNumber(value);
  }

  public static CodecAndBitrate forNumber(int value) {
    switch (value) {
      case 0: return UNDEFINED;
      case 6600: return AMRWB_BITRATE_6KBPS;
      case 8850: return AMRWB_BITRATE_8KBPS;
      case 12650: return AMRWB_BITRATE_12KBPS;
      case 14250: return AMRWB_BITRATE_14KBPS;
      case 15850: return AMRWB_BITRATE_15KBPS;
      case 18250: return AMRWB_BITRATE_18KBPS;
      case 19850: return AMRWB_BITRATE_19KBPS;
      case 23050: return AMRWB_BITRATE_23KBPS;
      case 23850: return AMRWB_BITRATE_24KBPS;
      case 1: return FLAC;
      case 12000: return OGG_OPUS_BITRATE_12KBPS;
      case 16000: return OGG_OPUS_BITRATE_16KBPS;
      case 24000: return OGG_OPUS_BITRATE_24KBPS;
      case 32000: return OGG_OPUS_BITRATE_32KBPS;
      case 64000: return OGG_OPUS_BITRATE_64KBPS;
      case 96000: return OGG_OPUS_BITRATE_96KBPS;
      case 128000: return OGG_OPUS_BITRATE_128KBPS;
      default: return null;
    }
  }

  public static com.google.protobuf.Internal.EnumLiteMap<CodecAndBitrate>
      internalGetValueMap() {
    return internalValueMap;
  }
  private static final com.google.protobuf.Internal.EnumLiteMap<
      CodecAndBitrate> internalValueMap =
        new com.google.protobuf.Internal.EnumLiteMap<CodecAndBitrate>() {
          public CodecAndBitrate findValueByNumber(int number) {
            return CodecAndBitrate.forNumber(number);
          }
        };

  public final com.google.protobuf.Descriptors.EnumValueDescriptor
      getValueDescriptor() {
    return getDescriptor().getValues().get(ordinal());
  }
  public final com.google.protobuf.Descriptors.EnumDescriptor
      getDescriptorForType() {
    return getDescriptor();
  }
  public static final com.google.protobuf.Descriptors.EnumDescriptor
      getDescriptor() {
    return com.google.audio.CodecAndBitrateOuterClass.getDescriptor().getEnumTypes().get(0);
  }

  private static final CodecAndBitrate[] VALUES = values();

  public static CodecAndBitrate valueOf(
      com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
    if (desc.getType() != getDescriptor()) {
      throw new java.lang.IllegalArgumentException(
        "EnumValueDescriptor is not for this type.");
    }
    return VALUES[desc.getIndex()];
  }

  private final int value;

  private CodecAndBitrate(int value) {
    this.value = value;
  }

  // @@protoc_insertion_point(enum_scope:audio.CodecAndBitrate)
}

